<http://star.siemens.com/ontology/instance#DesignPattern_async_methods> <http://www.w3.org/2000/01/rdf-schema#label> "Asynchronous method invocation"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_bridge> <http://www.w3.org/2000/01/rdf-schema#label> "Bridge pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_builder> <http://www.w3.org/2000/01/rdf-schema#label> "Builder pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_bulk_synchronous_parallel> <http://www.w3.org/2000/01/rdf-schema#label> "Bulk synchronous parallel"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_attribute-value_system> <http://www.w3.org/2000/01/rdf-schema#label> "Attribute-value system"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_breadcrumbs> <http://www.w3.org/2000/01/rdf-schema#label> "Breadcrumb (navigation)"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_adapter> <http://www.w3.org/2000/01/rdf-schema#label> "Adapter pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_chain_of_responsibility> <http://www.w3.org/2000/01/rdf-schema#label> "Chain-of-responsibility pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_abstract_factory> <http://www.w3.org/2000/01/rdf-schema#label> "Abstract factory pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_checksum> <http://www.w3.org/2000/01/rdf-schema#label> "Checksum"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_command> <http://www.w3.org/2000/01/rdf-schema#label> "Command pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_circuit_breaker> <http://www.w3.org/2000/01/rdf-schema#label> "Circuit breaker design pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_compensating_transaction_pattern> <http://www.w3.org/2000/01/rdf-schema#label> "Compensating transaction"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_composite> <http://www.w3.org/2000/01/rdf-schema#label> "Composite pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_data_logger> <http://www.w3.org/2000/01/rdf-schema#label> "Data logger"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_decorator> <http://www.w3.org/2000/01/rdf-schema#label> "Decorator pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_enterprise_integration_patterns> <http://www.w3.org/2000/01/rdf-schema#label> "Enterprise Integration Patterns"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_esb> <http://www.w3.org/2000/01/rdf-schema#label> "Enterprise service bus"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_eventual_consistency> <http://www.w3.org/2000/01/rdf-schema#label> "Eventual consistency"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_faceted_search_navigation> <http://www.w3.org/2000/01/rdf-schema#label> "Faceted search"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_facade> <http://www.w3.org/2000/01/rdf-schema#label> "Facade pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_factory_method> <http://www.w3.org/2000/01/rdf-schema#label> "Factory method pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_flyweight> <http://www.w3.org/2000/01/rdf-schema#label> "Flyweight pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_overloaded_functions> <http://www.w3.org/2000/01/rdf-schema#label> "Function overloading"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_interpretor> <http://www.w3.org/2000/01/rdf-schema#label> "Interpreter pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_leaky_bucket_counter> <http://www.w3.org/2000/01/rdf-schema#label> "Leaky bucket"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_lock> <http://www.w3.org/2000/01/rdf-schema#label> "Lock (computer science)"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_load_shedding> <http://www.w3.org/2000/01/rdf-schema#label> "Load Shedding"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_message_broker> <http://www.w3.org/2000/01/rdf-schema#label> "Message broker"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_load_balancing> <http://www.w3.org/2000/01/rdf-schema#label> "Load balancing (computing)"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_memento> <http://www.w3.org/2000/01/rdf-schema#label> "Memento pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_map_reduce> <http://www.w3.org/2000/01/rdf-schema#label> "MapReduce"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_mediator> <http://www.w3.org/2000/01/rdf-schema#label> "Mediator pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_microservices> <http://www.w3.org/2000/01/rdf-schema#label> "Microservices"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_modal_window> <http://www.w3.org/2000/01/rdf-schema#label> "Modal window"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_model-view-controller> <http://www.w3.org/2000/01/rdf-schema#label> "Model–view–controller"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_module> <http://www.w3.org/2000/01/rdf-schema#label> "Module pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_layered_architecture> <http://www.w3.org/2000/01/rdf-schema#label> "Multitier architecture"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_object_pool> <http://www.w3.org/2000/01/rdf-schema#label> "Object pool pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_observer> <http://www.w3.org/2000/01/rdf-schema#label> "Observer pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_priority_queue_pattern> <http://www.w3.org/2000/01/rdf-schema#label> "Priority queue"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_prototype> <http://www.w3.org/2000/01/rdf-schema#label> "Prototype pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_platform_invoke> <http://www.w3.org/2000/01/rdf-schema#label> "Platform Invocation Services"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_proxy> <http://www.w3.org/2000/01/rdf-schema#label> "Proxy pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_reflection> <http://www.w3.org/2000/01/rdf-schema#label> "Reflection (computer programming)"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_pubsub> <http://www.w3.org/2000/01/rdf-schema#label> "Publish–subscribe pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_replication> <http://www.w3.org/2000/01/rdf-schema#label> "Replication (computing)"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_representational_state_transfer> <http://www.w3.org/2000/01/rdf-schema#label> "Representational state transfer"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_request_response> <http://www.w3.org/2000/01/rdf-schema#label> "Request-response"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_rest_architecture> <http://www.w3.org/2000/01/rdf-schema#label> "Resource-oriented architecture"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_root_cause_analysis> <http://www.w3.org/2000/01/rdf-schema#label> "Root cause analysis"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_secure_channels> <http://www.w3.org/2000/01/rdf-schema#label> "Secure channel"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_serialization> <http://www.w3.org/2000/01/rdf-schema#label> "Serialization"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_service-oriented_architecture> <http://www.w3.org/2000/01/rdf-schema#label> "Service-oriented architecture"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_service_orientation> <http://www.w3.org/2000/01/rdf-schema#label> "Service-orientation"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_state> <http://www.w3.org/2000/01/rdf-schema#label> "State pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_singleton> <http://www.w3.org/2000/01/rdf-schema#label> "Singleton pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_strategy> <http://www.w3.org/2000/01/rdf-schema#label> "Strategy pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_template_method> <http://www.w3.org/2000/01/rdf-schema#label> "Template method pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_virtual_address_space> <http://www.w3.org/2000/01/rdf-schema#label> "Virtual address space"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_virtual_functions> <http://www.w3.org/2000/01/rdf-schema#label> "Virtual function"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_visitor> <http://www.w3.org/2000/01/rdf-schema#label> "Visitor pattern"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_async_methods> <http://www.w3.org/2000/01/rdf-schema#comment> "In multithreaded computer programming, asynchronous method invocation (AMI), also known as asynchronous method calls or the asynchronous pattern is a design pattern in which the call site is not blocked while waiting for the called code to finish. Instead, the calling thread is notified when the reply arrives. Polling for a reply is an undesired option."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_bridge> <http://www.w3.org/2000/01/rdf-schema#comment> "The bridge pattern is a design pattern used in software engineering that is meant to \"decouple an abstraction from its implementation so that the two can vary independently\", introduced by the Gang of Four. The bridge uses encapsulation, aggregation, and can use inheritance to separate responsibilities into different classes. When there is only one fixed implementation, this pattern is known as the Pimpl idiom in the C++ world. The bridge pattern is often confused with the adapter pattern, and is often implemented using the object adapter pattern, e.g. in the Java code below."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_builder> <http://www.w3.org/2000/01/rdf-schema#comment> "The builder pattern is a design pattern designed to provide a flexible solution to various object creation problems in object-oriented programming. The intent of the Builder design pattern is to separate the construction of a complex object from its representation. It is one of the Gang of Four design patterns."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_bulk_synchronous_parallel> <http://www.w3.org/2000/01/rdf-schema#comment> "The bulk synchronous parallel (BSP) abstract computer is a bridging model for designing parallel algorithms. It serves a purpose similar to the parallel random access machine (PRAM) model. BSP differs from PRAM by not taking communication and synchronization for granted. An important part of analyzing a BSP algorithm rests on quantifying the synchronization and communication needed."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_attribute-value_system> <http://www.w3.org/2000/01/rdf-schema#comment> "An attribute-value system is a basic knowledge representation framework comprising a table with columns designating \"attributes\" (also known as \"properties\", \"predicates,\" \"features,\" \"dimensions,\" \"characteristics\", \"fields\", \"headers\" or \"independent variables\" depending on the context) and \"rows\" designating \"objects\" (also known as \"entities,\" \"instances,\" \"exemplars,\" \"elements\", \"records\" or \"dependent variables\"). Each table cell therefore designates the value (also known as \"state\") of a particular attribute of a particular object."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_adapter> <http://www.w3.org/2000/01/rdf-schema#comment> "In software engineering, the adapter pattern is a software design pattern (also known as wrapper, an alternative naming shared with the decorator pattern) that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code. An example is an adapter that converts the interface of a Document Object Model of an XML document into a tree structure that can be displayed."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_chain_of_responsibility> <http://www.w3.org/2000/01/rdf-schema#comment> "In object-oriented design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain. A mechanism also exists for adding new processing objects to the end of this chain. Thus, the chain of responsibility is an object oriented version of the if ... else if ... else if ....... else ... endif idiom, with the benefit that the condition–action blocks can be dynamically rearranged and reconfigured at runtime."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_abstract_factory> <http://www.w3.org/2000/01/rdf-schema#comment> "The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes. In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interface of the factory to create the concrete objects that are part of the theme. The client doesn't know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products. This pattern separates the details of implementation of a set of objects from their general usage and relies on object composition, as object creation is implemented in methods exposed in the factory interface."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_checksum> <http://www.w3.org/2000/01/rdf-schema#comment> "A checksum is a small-sized datum derived from a block of digital data for the purpose of detecting errors that may have been introduced during its transmission or storage. By themselves, checksums are often used to verify data integrity but are not relied upon to verify data authenticity."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_command> <http://www.w3.org/2000/01/rdf-schema#comment> "In object-oriented programming, the command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time. This information includes the method name, the object that owns the method and values for the method parameters. The central ideas of this design pattern closely mirror the semantics of first-class functions and higher-order functions in functional programming languages. Specifically, the invoker object is a higher-order function of which the command object is a first-class argument."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_circuit_breaker> <http://www.w3.org/2000/01/rdf-schema#comment> "Circuit breaker is a design pattern used in modern software development. It is used to detect failures and encapsulates the logic of preventing a failure from constantly recurring, during maintenance, temporary external system failure or unexpected system difficulties."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_compensating_transaction_pattern> <http://www.w3.org/2000/01/rdf-schema#comment> "The execution of a business process consists of one or more transactions. Each transaction may consist of several individual operations yet, as a whole, it moves the system between consistent states. There are two groups of systems where compensating transaction may be applied: 1. In the context of a database this is often easily achieved using transactions and the commit/rollback mechanism. Compensating transaction logic could be implemented as additional on top of database supporting commit/rollback. In that case we can decrease business transaction granularity."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_composite> <http://www.w3.org/2000/01/rdf-schema#comment> "In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes a group of objects that are treated the same way as a single instance of the same type of object. The intent of a composite is to \"compose\" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_data_logger> <http://www.w3.org/2000/01/rdf-schema#comment> "A data logger (also datalogger or data recorder) is an electronic device that records data over time or in relation to location either with a built in instrument or sensor or via external instruments and sensors. Increasingly, but not entirely, they are based on a digital processor (or computer). They generally are small, battery powered, portable, and equipped with a microprocessor, internal memory for data storage, and sensors. Some data loggers interface with a personal computer, and use software to activate the data logger and view and analyze the collected data, while others have a local interface device (keypad, LCD) and can be used as a stand-alone device."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_decorator> <http://www.w3.org/2000/01/rdf-schema#comment> "In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern. The decorator pattern is structurally nearly identical to the chain of responsibility pattern, the difference being that in a chain of responsibility, exactly one of the classes handles the request, while for the decorator, all classes handle the request."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_enterprise_integration_patterns> <http://www.w3.org/2000/01/rdf-schema#comment> "Enterprise Integration Patterns is a book by Gregor Hohpe and Bobby Woolf and describes 65 patterns for the use of enterprise application integration and message-oriented middleware in the form of a pattern language."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_esb> <http://www.w3.org/2000/01/rdf-schema#comment> "An enterprise service bus (ESB) implements a communication system between mutually interacting software applications in a service-oriented architecture (SOA). It represents a software architecture for distributed computing, and is a special variant of the more general client-server model, wherein any application may behave as server or client. ESB promotes agility and flexibility with regard to high-level protocol communication between applications. Its primary use is in enterprise application integration (EAI) of heterogeneous and complex service landscapes."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_eventual_consistency> <http://www.w3.org/2000/01/rdf-schema#comment> "Eventual consistency is a consistency model used in distributed computing to achieve high availability that informally guarantees that, if no new updates are made to a given data item, eventually all accesses to that item will return the last updated value. Eventual consistency, also called optimistic replication, is widely deployed in distributed systems, and has origins in early mobile computing projects. A system that has achieved eventual consistency is often said to have converged, or achieved replica convergence. Eventual consistency is a weak guarantee – most stronger models, like linearizability are trivially eventually consistent, but a system that is merely eventually consistent does not usually fulfill these stronger constraints."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_faceted_search_navigation> <http://www.w3.org/2000/01/rdf-schema#comment> "Faceted search is a technique which involves augmenting traditional search techniques with a faceted navigation system, allowing users to narrow down search results by applying multiple filters based on faceted classification of the items. A faceted classification system classifies each information element along multiple explicit dimensions, called facets, enabling the classifications to be accessed and ordered in multiple ways rather than in a single, pre-determined, taxonomic order."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_facade> <http://www.w3.org/2000/01/rdf-schema#comment> "The facade pattern (also spelled façade) is a  software-design pattern commonly used in object-oriented programming. Analogous to a facade in architecture, a facade is an object that serves as a front-facing interface masking more complex underlying or structural code. A facade can:"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_factory_method> <http://www.w3.org/2000/01/rdf-schema#comment> "In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created. This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_flyweight> <http://www.w3.org/2000/01/rdf-schema#comment> "In computer programming, flyweight is a software design pattern. A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory. Often some parts of the object state can be shared, and it is common practice to hold them in external data structures and pass them to the objects temporarily when they are used. Another example is string interning."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_overloaded_functions> <http://www.w3.org/2000/01/rdf-schema#comment> "In some programming languages, function overloading or method overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_interpretor> <http://www.w3.org/2000/01/rdf-schema#comment> "In computer programming, the interpreter pattern is a design pattern that specifies how to evaluate sentences in a language.The basic idea is to have a class for each symbol (terminal or nonterminal) in a specialized computer language. The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client. See also Composite pattern."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_leaky_bucket_counter> <http://www.w3.org/2000/01/rdf-schema#comment> "The leaky bucket is an algorithm based on an analogy of how a bucket with a leak will overflow if either the average rate at which water is poured in exceeds the rate at which the bucket leaks or if more water than the capacity of the bucket is poured in all at once, and how the water leaks from the bucket at an (almost) constant rate. It can be used to determine whether some sequence of discrete events conforms to defined limits on their average and peak rates or frequencies, or whether to limit, directly, the actions associated to these events to these rates, and may be used to limit these actions to an average rate alone, i.e. remove any variation from the average."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_lock> <http://www.w3.org/2000/01/rdf-schema#comment> "In computer science, a lock or mutex (from mutual exclusion) is a synchronization mechanism for enforcing limits on access to a resource in an environment where there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_message_broker> <http://www.w3.org/2000/01/rdf-schema#comment> "A message broker (also known as an integration broker or interface engine) is an intermediary computer program module that translates a message from the formal messaging protocol of the sender to the formal messaging protocol of the receiver. Message brokers are elements in telecommunication or computer networks where software applications communicate by exchanging formally-defined messages. Message brokers are a building block of message-oriented middleware (MOM) but are typically not a replacement for traditional middleware like MOM and remote procedure call (RPC)."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_load_balancing> <http://www.w3.org/2000/01/rdf-schema#comment> "In computing, load balancing improves the distribution of workloads across multiple computing resources, such as computers, a computer cluster, network links, central processing units, or disk drives. Load balancing aims to optimize resource use, maximize throughput, minimize response time, and avoid overload of any single resource. Using multiple components with load balancing instead of a single component may increase reliability and availability through redundancy. Load balancing usually involves dedicated software or hardware, such as a multilayer switch or a Domain Name System server process."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_memento> <http://www.w3.org/2000/01/rdf-schema#comment> "The memento pattern is a software design pattern that provides the ability to restore an object to its previous state (undo via rollback). The memento pattern is implemented with three objects: the originator, a caretaker and a memento. The originator is some object that has an internal state. The caretaker is going to do something to the originator, but wants to be able to undo the change. The caretaker first asks the originator for a memento object. Then it does whatever operation (or sequence of operations) it was going to do. To roll back to the state before the operations, it returns the memento object to the originator. The memento object itself is an opaque object (one which the caretaker cannot, or should not, change). When using this pattern, care should be taken if the originator"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_map_reduce> <http://www.w3.org/2000/01/rdf-schema#comment> "MapReduce is a programming model and an associated implementation for processing and generating big data sets with a parallel, distributed algorithm on a cluster. A MapReduce program is composed of a map procedure, which performs filtering and sorting (such as sorting students by first name into queues, one queue for each name), and a reduce method, which performs a summary operation (such as counting the number of students in each queue, yielding name frequencies). The \"MapReduce System\" (also called \"infrastructure\" or \"framework\") orchestrates the processing by marshalling the distributed servers, running the various tasks in parallel, managing all communications and data transfers between the various parts of the system, and providing for redundancy and fault tolerance."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_mediator> <http://www.w3.org/2000/01/rdf-schema#comment> "In software engineering, the mediator pattern defines an object that encapsulates how a set of objects interact. This pattern is considered to be a behavioral pattern due to the way it can alter the program's running behavior. With the mediator pattern, communication between objects is encapsulated within a mediator object. Objects no longer communicate directly with each other, but instead communicate through the mediator. This reduces the dependencies between communicating objects, thereby reducing coupling."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_microservices> <http://www.w3.org/2000/01/rdf-schema#comment> "Microservices are a software development technique —a variant of the service-oriented architecture (SOA) structural style— that arranges an application as a collection of loosely coupled services. In a microservices architecture, services are fine-grained and the protocols are lightweight."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_modal_window> <http://www.w3.org/2000/01/rdf-schema#comment> "In user interface design for computer applications, a modal window is a graphical control element subordinate to an application's main window. It creates a mode that disables the main window but keeps it visible, with the modal window as a child window in front of it. Users must interact with the modal window before they can return to the parent application. This avoids interrupting the workflow on the main window. Modal windows are sometimes called heavy windows or modal dialogs because they often display a dialog box."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_model-view-controller> <http://www.w3.org/2000/01/rdf-schema#comment> "Model–view–controller (usually known as MVC) is a software design pattern commonly used for developing user interfaces which divides the related program logic into three interconnected elements. This is done to separate internal representations of information from the ways information is presented to and accepted from the user. This kind of pattern is used for designing the layout of the page."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_module> <http://www.w3.org/2000/01/rdf-schema#comment> "In software engineering, the module pattern is a design pattern used to implement the concept of software modules, defined by modular programming, in a programming language with incomplete direct support for the concept. This pattern can be implemented in several ways depending on the host programming language, such as the singleton design pattern, object-oriented  in a class and procedural global functions. In Python, the pattern is built into the language, and each .py file is automatically a module."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_layered_architecture> <http://www.w3.org/2000/01/rdf-schema#comment> "In software engineering, multitier architecture (often referred to as n-tier architecture) or multilayered architecture is a client–server architecture in which presentation, application processing, and data management functions are physically separated. The most widespread use of multitier architecture is the three-tier architecture."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_object_pool> <http://www.w3.org/2000/01/rdf-schema#comment> "The object pool pattern is a software creational design pattern that uses a set of initialized objects kept ready to use – a \"pool\" – rather than allocating and destroying them on demand. A client of the pool will request an object from the pool and perform operations on the returned object. When the client has finished, it returns the object to the pool rather than destroying it; this can be done manually or automatically."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_observer> <http://www.w3.org/2000/01/rdf-schema#comment> "The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_priority_queue_pattern> <http://www.w3.org/2000/01/rdf-schema#comment> "In computer science, a priority queue is an abstract data type which is like a regular queue or stack data structure, but where additionally each element has a \"priority\" associated with it. In a priority queue, an element with high priority is served before an element with low priority. In some implementations, if two elements have the same priority, they are served according to the order in which they were enqueued, while in other implementations, ordering of elements with the same priority is undefined."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_prototype> <http://www.w3.org/2000/01/rdf-schema#comment> "The prototype pattern is a creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects. This pattern is used to: \n* avoid subclasses of an object creator in the client application, like the factory method pattern does. \n* avoid the inherent cost of creating a new object in the standard way (e.g., using the 'new' keyword) when it is prohibitively expensive for a given application."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_platform_invoke> <http://www.w3.org/2000/01/rdf-schema#comment> "Platform Invocation Services, commonly referred to as P/Invoke, is a feature of Common Language Infrastructure implementations, like Microsoft's Common Language Runtime, that enables managed code to call native code."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_proxy> <http://www.w3.org/2000/01/rdf-schema#comment> "In computer programming, the proxy pattern is a software design pattern. A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy, extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked. For the client, usage of a proxy o"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_reflection> <http://www.w3.org/2000/01/rdf-schema#comment> "In computer science, reflection is the ability of a process to examine, introspect, and modify its own structure and behavior."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_pubsub> <http://www.w3.org/2000/01/rdf-schema#comment> "In software architecture, publish–subscribe is a messaging pattern where senders of messages, called publishers, do not program the messages to be sent directly to specific receivers, called subscribers, but instead categorize published messages into classes without knowledge of which subscribers, if any, there may be. Similarly, subscribers express interest in one or more classes and only receive messages that are of interest, without knowledge of which publishers, if any, there are."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_replication> <http://www.w3.org/2000/01/rdf-schema#comment> "Replication in computing involves sharing information so as to ensure consistency between redundant resources, such as software or hardware components, to improve reliability, fault-tolerance, or accessibility."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_representational_state_transfer> <http://www.w3.org/2000/01/rdf-schema#comment> "Representational state transfer (REST) is a software architectural style that defines a set of constraints to be used for creating Web services. Web services that conform to the REST architectural style, called RESTful Web services, provide interoperability between computer systems on the Internet. RESTful Web services allow the requesting systems to access and manipulate textual representations of Web resources by using a uniform and predefined set of stateless operations. Other kinds of Web services, such as SOAP Web services, expose their own arbitrary sets of operations."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_rest_architecture> <http://www.w3.org/2000/01/rdf-schema#comment> "In software engineering, a resource-oriented architecture (ROA) is a style of software architecture and programming paradigm for supportive designing and developing software in the form of Internetworking of resources with \"RESTful\" interfaces. These resources are software components (discrete pieces of code and/or data structures) which can be reused for different purposes. ROA design principles and guidelines are used during the phases of software development and system integration."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_root_cause_analysis> <http://www.w3.org/2000/01/rdf-schema#comment> "In science and engineering, root cause analysis (RCA) is a method of problem solving used for identifying the root causes of faults or problems. It is widely used in IT operations, telecommunications, industrial process control, accident analysis (e.g., in aviation, rail transport, or nuclear plants), medicine (for medical diagnosis), healthcare industry (e.g., for epidemiology), etc. RCA can be decomposed into four steps:"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_secure_channels> <http://www.w3.org/2000/01/rdf-schema#comment> "In cryptography, a secure channel is a way of transferring data that is resistant to overhearing and tampering. A  is a way of transferring data that is resistant to overhearing (i.e., reading the content), but not necessarily resistant to tampering. An  is a way of transferring data that is resistant to tampering but not necessarily resistant to overhearing."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_serialization> <http://www.w3.org/2000/01/rdf-schema#comment> "In computer science, in the context of data storage, serialization (or serialisation) is the process of translating data structures or object state into a format that can be stored (for example, in a file or memory buffer) or transmitted (for example, across a network connection link) and reconstructed later (possibly in a different computer environment). When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object. For many complex objects, such as those that make extensive use of references, this process is not straightforward. Serialization of object-oriented objects does not include any of their associated methods with which they were previously linked."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_service-oriented_architecture> <http://www.w3.org/2000/01/rdf-schema#comment> "Service-oriented architecture (SOA) is a style of software design where services are provided to the other components by application components, through a communication protocol over a network. A SOA service is a discrete unit of functionality that can be accessed remotely and acted upon and updated independently, such as retrieving a credit card statement online. SOA is also intended to be independent of vendors, products and technologies. A service has four properties according to one of many definitions of SOA:"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_service_orientation> <http://www.w3.org/2000/01/rdf-schema#comment> "Service-orientation is a design paradigm for computer software in the form of services. The principles of service-oriented design stress the separation of concerns in the software. Applying service-orientation results in units of software partitioned into discrete, autonomous, and network-accessible units, each designed to solve an individual concern. These units qualify as services."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_state> <http://www.w3.org/2000/01/rdf-schema#comment> "The state pattern is a behavioral software design pattern that allows an object to alter its behavior when its internal state changes. This pattern is close to the concept of finite-state machines. The state pattern can be interpreted as a strategy pattern, which is able to switch a strategy through invocations of methods defined in the pattern's interface."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_singleton> <http://www.w3.org/2000/01/rdf-schema#comment> "In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one \"single\" instance. This is useful when exactly one object is needed to coordinate actions across the system. The term comes from the mathematical concept of a singleton. Critics consider the singleton to be an anti-pattern in that it is frequently used in scenarios where it is not beneficial, introduces unnecessary restrictions in situations where a sole instance of a class is not actually required, and introduces global state into an application."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_strategy> <http://www.w3.org/2000/01/rdf-schema#comment> "In computer programming, the strategy pattern (also known as the policy pattern) is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_template_method> <http://www.w3.org/2000/01/rdf-schema#comment> "In object-oriented programming, the template method is one of the behavioral design patterns identified by Gamma et al. in the book Design Patterns. The template method is a method in a superclass, usually an abstract superclass, and defines the skeleton of an operation in terms of a number of high-level steps. These steps are themselves implemented by additional helper methods in the same class as the template method."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_virtual_address_space> <http://www.w3.org/2000/01/rdf-schema#comment> "In computing, a virtual address space (VAS) or address space is the set of ranges of virtual addresses that an operating system makes available to a process. The range of virtual addresses usually starts at a low address and can extend to the highest address allowed by the computer's instruction set architecture and supported by the operating system's pointer size implementation, which can be 4 bytes for 32-bit or 8 bytes for 64-bit OS versions. This provides several benefits, one of which is security through process isolation assuming each process is given a separate address space."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_virtual_functions> <http://www.w3.org/2000/01/rdf-schema#comment> "In object-oriented programming, in languages such as C++, and Object Pascal, a virtual function or virtual method is an inheritable and overridable function or method for which dynamic dispatch is facilitated. This concept is an important part of the (runtime) polymorphism portion of object-oriented programming (OOP). In short, a virtual function defines a target function to be executed, but the target might not be known at compile time."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_visitor> <http://www.w3.org/2000/01/rdf-schema#comment> "In object-oriented programming and software engineering, the visitor design pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying the structures. It is one way to follow the open/closed principle."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_async_methods> <http://dbpedia.org/ontology/abstract> "In multithreaded computer programming, asynchronous method invocation (AMI), also known as asynchronous method calls or the asynchronous pattern is a design pattern in which the call site is not blocked while waiting for the called code to finish. Instead, the calling thread is notified when the reply arrives. Polling for a reply is an undesired option."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_bridge> <http://dbpedia.org/ontology/abstract> "The bridge pattern is a design pattern used in software engineering that is meant to \"decouple an abstraction from its implementation so that the two can vary independently\", introduced by the Gang of Four. The bridge uses encapsulation, aggregation, and can use inheritance to separate responsibilities into different classes. When a class varies often, the features of object-oriented programming become very useful because changes to a program's code can be made easily with minimal prior knowledge about the program. The bridge pattern is useful when both the class and what it does vary often. The class itself can be thought of as the abstraction and what the class can do as the implementation. The bridge pattern can also be thought of as two layers of abstraction. When there is only one fixed implementation, this pattern is known as the Pimpl idiom in the C++ world. The bridge pattern is often confused with the adapter pattern, and is often implemented using the object adapter pattern, e.g. in the Java code below. Variant: The implementation can be decoupled even more by deferring the presence of the implementation to the point where the abstraction is utilized."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_builder> <http://dbpedia.org/ontology/abstract> "The builder pattern is a design pattern designed to provide a flexible solution to various object creation problems in object-oriented programming. The intent of the Builder design pattern is to separate the construction of a complex object from its representation. It is one of the Gang of Four design patterns."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_bulk_synchronous_parallel> <http://dbpedia.org/ontology/abstract> "The bulk synchronous parallel (BSP) abstract computer is a bridging model for designing parallel algorithms. It serves a purpose similar to the parallel random access machine (PRAM) model. BSP differs from PRAM by not taking communication and synchronization for granted. An important part of analyzing a BSP algorithm rests on quantifying the synchronization and communication needed."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_attribute-value_system> <http://dbpedia.org/ontology/abstract> "An attribute-value system is a basic knowledge representation framework comprising a table with columns designating \"attributes\" (also known as \"properties\", \"predicates,\" \"features,\" \"dimensions,\" \"characteristics\", \"fields\", \"headers\" or \"independent variables\" depending on the context) and \"rows\" designating \"objects\" (also known as \"entities,\" \"instances,\" \"exemplars,\" \"elements\", \"records\" or \"dependent variables\"). Each table cell therefore designates the value (also known as \"state\") of a particular attribute of a particular object."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_adapter> <http://dbpedia.org/ontology/abstract> "In software engineering, the adapter pattern is a software design pattern (also known as wrapper, an alternative naming shared with the decorator pattern) that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code. An example is an adapter that converts the interface of a Document Object Model of an XML document into a tree structure that can be displayed."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_chain_of_responsibility> <http://dbpedia.org/ontology/abstract> "In object-oriented design, the chain-of-responsibility pattern is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain. A mechanism also exists for adding new processing objects to the end of this chain. Thus, the chain of responsibility is an object oriented version of the if ... else if ... else if ....... else ... endif idiom, with the benefit that the condition–action blocks can be dynamically rearranged and reconfigured at runtime. In a variation of the standard chain-of-responsibility model, some handlers may act as dispatchers, capable of sending commands out in a variety of directions, forming a tree of responsibility. In some cases, this can occur recursively, with processing objects calling higher-up processing objects with commands that attempt to solve some smaller part of the problem; in this case recursion continues until the command is processed, or the entire tree has been explored. An XML interpreter might work in this manner. This pattern promotes the idea of loose coupling. The chain-of-responsibility pattern is structurally nearly identical to the decorator pattern, the difference being that for the decorator, all classes handle the request, while for the chain of responsibility, exactly one of the classes in the chain handles the request. This is a strict definition of the Responsibility concept in the GoF book. However, many implementations (such as loggers below, or UI event handling, or servlet filters in Java, etc) allow several elements in the chain to take responsibility."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_abstract_factory> <http://dbpedia.org/ontology/abstract> "The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes. In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interface of the factory to create the concrete objects that are part of the theme. The client doesn't know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products. This pattern separates the details of implementation of a set of objects from their general usage and relies on object composition, as object creation is implemented in methods exposed in the factory interface. An example of this would be an abstract factory class DocumentCreator that provides interfaces to create a number of products (e.g. createLetter() and createResume()). The system would have any number of derived concrete versions of the DocumentCreator class like FancyDocumentCreator or ModernDocumentCreator, each with a different implementation of createLetter() and createResume() that would create a corresponding object like FancyLetter or ModernResume. Each of these products is derived from a simple abstract class like Letter or Resume of which the client is aware. The client code would get an appropriate instance of the DocumentCreator and call its factory methods. Each of the resulting objects would be created from the same DocumentCreator implementation and would share a common theme (they would all be fancy or modern objects). The client would only need to know how to handle the abstract Letter or Resume class, not the specific version that it got from the concrete factory. A factory is the location of a concrete class in the code at which objects are constructed. The intent in employing the pattern is to insulate the creation of objects from their usage and to create families of related objects without having to depend on their concrete classes. This allows for new derived types to be introduced with no change to the code that uses the base class. Use of this pattern makes it possible to interchange concrete implementations without changing the code that uses them, even at runtime. However, employment of this pattern, as with similar design patterns, may result in unnecessary complexity and extra work in the initial writing of code. Additionally, higher levels of separation and abstraction can result in systems that are more difficult to debug and maintain."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_checksum> <http://dbpedia.org/ontology/abstract> "A checksum is a small-sized datum derived from a block of digital data for the purpose of detecting errors that may have been introduced during its transmission or storage. By themselves, checksums are often used to verify data integrity but are not relied upon to verify data authenticity. The procedure which generates this checksum is called a checksum function or checksum algorithm. Depending on its design goals, a good checksum algorithm will usually output a significantly different value, even for small changes made to the input. This is especially true of cryptographic hash functions, which may be used to detect many data corruption errors and verify overall data integrity; if the computed checksum for the current data input matches the stored value of a previously computed checksum, there is a very high probability the data has not been accidentally altered or corrupted. Checksum functions are related to hash functions, fingerprints, randomization functions, and cryptographic hash functions. However, each of those concepts has different applications and therefore different design goals. For instance, a function returning the start of a string can provide a hash appropriate for some applications but will never be a suitable checksum. Checksums are used as cryptographic primitives in larger authentication algorithms. For cryptographic systems with these two specific design goals, see HMAC. Check digits and parity bits are special cases of checksums, appropriate for small blocks of data (such as Social Security numbers, bank account numbers, computer words, single bytes, etc.). Some error-correcting codes are based on special checksums which not only detect common errors but also allow the original data to be recovered in certain cases."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_command> <http://dbpedia.org/ontology/abstract> "In object-oriented programming, the command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time. This information includes the method name, the object that owns the method and values for the method parameters. Four terms always associated with the command pattern are command, receiver, invoker and client. A command object knows about receiver and invokes a method of the receiver. Values for parameters of the receiver method are stored in the command. The receiver object to execute these methods is also stored in the command object by aggregation. The receiver then does the work when the execute() method in command is called. An invoker object knows how to execute a command, and optionally does bookkeeping about the command execution. The invoker does not know anything about a concrete command, it knows only about the command interface. Invoker object(s), command objects and receiver objects are held by a client object, the client decides which receiver objects it assigns to the command objects, and which commands it assigns to the invoker. The client decides which commands to execute at which points. To execute a command, it passes the command object to the invoker object. Using command objects makes it easier to construct general components that need to delegate, sequence or execute method calls at a time of their choosing without the need to know the class of the method or the method parameters. Using an invoker object allows bookkeeping about command executions to be conveniently performed, as well as implementing different modes for commands, which are managed by the invoker object, without the need for the client to be aware of the existence of bookkeeping or modes. The central ideas of this design pattern closely mirror the semantics of first-class functions and higher-order functions in functional programming languages. Specifically, the invoker object is a higher-order function of which the command object is a first-class argument."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_circuit_breaker> <http://dbpedia.org/ontology/abstract> "Circuit breaker is a design pattern used in modern software development. It is used to detect failures and encapsulates the logic of preventing a failure from constantly recurring, during maintenance, temporary external system failure or unexpected system difficulties."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_compensating_transaction_pattern> <http://dbpedia.org/ontology/abstract> "The execution of a business process consists of one or more transactions. Each transaction may consist of several individual operations yet, as a whole, it moves the system between consistent states. There are two groups of systems where compensating transaction may be applied: 1. In the context of a database this is often easily achieved using transactions and the commit/rollback mechanism. Compensating transaction logic could be implemented as additional on top of database supporting commit/rollback. In that case we can decrease business transaction granularity. 2. For systems without a commit/rollback mechanism available, one can undo a failed transaction with a compensating transaction, which will bring the system back to its initial state. Typically, this is only a workaround which has to be implemented manually and cannot guarantee that the system always ends in a consistent state. The system designer may need to consider what happens if the compensating transaction also fails. Compensating transactions are also used in case where a transaction is long lived (commonly called Saga Transactions), for instance in a business process requiring user input. In such cases data will be committed to permanent storage, but may subsequently need to be rolled back, perhaps due to the user opting to cancel the operation. Unlike conventional rollbacks, specific business logic will typically be required to roll back a long lived transaction and restore the system to its original state. This type of transaction differs from distributed transactions (often implemented using the two-phase-commit protocol), because although both types of transactions can result in multiple data stores being updated, compensating transactions allows for the updates to span a long period of time. Compensating transactions are often designed into Web services that participate in the execution of business processes that are part of a service-oriented architecture solution."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_composite> <http://dbpedia.org/ontology/abstract> "In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes a group of objects that are treated the same way as a single instance of the same type of object. The intent of a composite is to \"compose\" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_data_logger> <http://dbpedia.org/ontology/abstract> "A data logger (also datalogger or data recorder) is an electronic device that records data over time or in relation to location either with a built in instrument or sensor or via external instruments and sensors. Increasingly, but not entirely, they are based on a digital processor (or computer). They generally are small, battery powered, portable, and equipped with a microprocessor, internal memory for data storage, and sensors. Some data loggers interface with a personal computer, and use software to activate the data logger and view and analyze the collected data, while others have a local interface device (keypad, LCD) and can be used as a stand-alone device. Data loggers vary between general purpose types for a range of measurement applications to very specific devices for measuring in one environment or application type only. It is common for general purpose types to be programmable; however, many remain as static machines with only a limited number or no changeable parameters. Electronic data loggers have replaced chart recorders in many applications. One of the primary benefits of using data loggers is the ability to automatically collect data on a 24-hour basis. Upon activation, data loggers are typically deployed and left unattended to measure and record information for the duration of the monitoring period. This allows for a comprehensive, accurate picture of the environmental conditions being monitored, such as air temperature and relative humidity. The cost of data loggers has been declining over the years as technology improves and costs are reduced. Simple single channel data loggers cost as little as $25. More complicated loggers may costs hundreds or thousands of dollars."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_decorator> <http://dbpedia.org/ontology/abstract> "In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to be divided between classes with unique areas of concern. The decorator pattern is structurally nearly identical to the chain of responsibility pattern, the difference being that in a chain of responsibility, exactly one of the classes handles the request, while for the decorator, all classes handle the request."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_enterprise_integration_patterns> <http://dbpedia.org/ontology/abstract> "Enterprise Integration Patterns is a book by Gregor Hohpe and Bobby Woolf and describes 65 patterns for the use of enterprise application integration and message-oriented middleware in the form of a pattern language."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_esb> <http://dbpedia.org/ontology/abstract> "An enterprise service bus (ESB) implements a communication system between mutually interacting software applications in a service-oriented architecture (SOA). It represents a software architecture for distributed computing, and is a special variant of the more general client-server model, wherein any application may behave as server or client. ESB promotes agility and flexibility with regard to high-level protocol communication between applications. Its primary use is in enterprise application integration (EAI) of heterogeneous and complex service landscapes."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_eventual_consistency> <http://dbpedia.org/ontology/abstract> "Eventual consistency is a consistency model used in distributed computing to achieve high availability that informally guarantees that, if no new updates are made to a given data item, eventually all accesses to that item will return the last updated value. Eventual consistency, also called optimistic replication, is widely deployed in distributed systems, and has origins in early mobile computing projects. A system that has achieved eventual consistency is often said to have converged, or achieved replica convergence. Eventual consistency is a weak guarantee – most stronger models, like linearizability are trivially eventually consistent, but a system that is merely eventually consistent does not usually fulfill these stronger constraints. Eventually-consistent services are often classified as providing BASE (Basically Available, Soft state, Eventual consistency) semantics, in contrast to traditional ACID (Atomicity, Consistency, Isolation, Durability) guarantees. In chemistry BASE is opposite to ACID, which helps remembering the acronym. According to the same resource, these are the rough definitions of each term in BASE: \n* (B)asically (A)vailable: basic reading and writing operations are available as much as possible (using all nodes of a database cluster), but without any kind of consistency guarantees (the write may not persist after conflicts are reconciled, the read may not get the latest write) \n* (S)oft state: without consistency guarantees, after some amount of time, we only have some probability of knowing the state, since it may not yet have converged \n* (E)ventually consistent: If the system is functioning and we wait long enough after any given set of inputs, we will eventually be able to know what the state of the database is, and so any further reads will be consistent with our expectations Eventual consistency is sometimes criticized as increasing the complexity of distributed software applications. This is partly because eventual consistency is purely a liveness guarantee (reads eventually return the same value) and does not make safety guarantees: an eventually consistent system can return any value before it converges."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_faceted_search_navigation> <http://dbpedia.org/ontology/abstract> "Faceted search is a technique which involves augmenting traditional search techniques with a faceted navigation system, allowing users to narrow down search results by applying multiple filters based on faceted classification of the items. A faceted classification system classifies each information element along multiple explicit dimensions, called facets, enabling the classifications to be accessed and ordered in multiple ways rather than in a single, pre-determined, taxonomic order. Facets correspond to properties of the information elements. They are often derived by analysis of the text of an item using entity extraction techniques or from pre-existing fields in a database such as author, descriptor, language, and format. Thus, existing web-pages, product descriptions or online collections of articles can be augmented with navigational facets. Within the academic community, faceted search has attracted interest primarily among library and information science researchers, and to some extent among computer science researchers specializing in information retrieval."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_facade> <http://dbpedia.org/ontology/abstract> "The facade pattern (also spelled façade) is a  software-design pattern commonly used in object-oriented programming. Analogous to a facade in architecture, a facade is an object that serves as a front-facing interface masking more complex underlying or structural code. A facade can: \n* improve the readability and usability of a software library by masking interaction with more complex components behind a single (and often simplified) API \n* provide a context-specific interface to more generic functionality (complete with context-specific input validation) \n* serve as a launching point for a broader refactor of monolithic or tightly-coupled systems in favor of more loosely-coupled code Developers often use the facade design pattern when a system is very complex or difficult to understand because the system has many interdependent classes or because its source code is unavailable. This pattern hides the complexities of the larger system and provides a simpler interface to the client. It typically involves a single wrapper class that contains a set of members required by the client. These members access the system on behalf of the facade client and hide the implementation details."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_factory_method> <http://dbpedia.org/ontology/abstract> "In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created. This is done by creating objects by calling a factory method—either specified in an interface and implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather than by calling a constructor."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_flyweight> <http://dbpedia.org/ontology/abstract> "In computer programming, flyweight is a software design pattern. A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory. Often some parts of the object state can be shared, and it is common practice to hold them in external data structures and pass them to the objects temporarily when they are used. A classic example usage of the flyweight pattern is the data structures for graphical representation of characters in a word processor. It might be desirable to have, for each character in a document, a glyph object containing its font outline, font metrics, and other formatting data, but this would amount to hundreds or thousands of bytes for each character. Instead, for every character there might be a reference to a flyweight glyph object shared by every instance of the same character in the document; only the position of each character (in the document and/or the page) would need to be stored internally. Another example is string interning. In other contexts the idea of sharing identical data structures is called hash consing."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_overloaded_functions> <http://dbpedia.org/ontology/abstract> "In some programming languages, function overloading or method overloading is the ability to create multiple functions of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context. For example, doTask() and doTask(object O) are overloaded functions. To call the latter, an object must be passed as a parameter, whereas the former does not require a parameter, and is called with an empty parameter field. A common error would be to assign a default value to the object in the second function, which would result in an ambiguous call error, as the compiler wouldn't know which of the two methods to use. Another example is a Print(object O) function that executes different actions based on whether it's printing text or photos. The two different functions may be overloaded as Print(text_object T); Print(image_object P). If we write the overloaded print functions for all objects our program will \"print\", we never have to worry about the type of the object, and the correct function call again, the call is always: Print(something)."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_interpretor> <http://dbpedia.org/ontology/abstract> "In computer programming, the interpreter pattern is a design pattern that specifies how to evaluate sentences in a language.The basic idea is to have a class for each symbol (terminal or nonterminal) in a specialized computer language. The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client. See also Composite pattern."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_leaky_bucket_counter> <http://dbpedia.org/ontology/abstract> "The leaky bucket is an algorithm based on an analogy of how a bucket with a leak will overflow if either the average rate at which water is poured in exceeds the rate at which the bucket leaks or if more water than the capacity of the bucket is poured in all at once, and how the water leaks from the bucket at an (almost) constant rate. It can be used to determine whether some sequence of discrete events conforms to defined limits on their average and peak rates or frequencies, or whether to limit, directly, the actions associated to these events to these rates, and may be used to limit these actions to an average rate alone, i.e. remove any variation from the average. It is used in packet-switched computer networks and telecommunications networks in both the traffic policing and traffic shaping of data transmissions, in the form of packets, to defined limits on bandwidth and burstiness (a measure of the unevenness or variations in the traffic flow). It can also be used as a scheduling algorithm to determine the timing of transmissions that will comply with the limits set for the bandwidth and burstiness applied by the network: see network scheduler. A version of the leaky bucket, the generic cell rate algorithm, is recommended for asynchronous transfer mode (ATM) networks in Usage/Network Parameter Control at user–network interfaces or inter-network interfaces or network-to-network interfaces to protect a network from excessive traffic levels on connections routed through it. The generic cell rate algorithm, or an equivalent, may also be used to shape transmissions by a network interface card onto an ATM network (i.e. on the user side of the user-network interface), e.g. to levels below the levels set for Usage/Network Parameter Control in the network to prevent it taking action to further limit that connection. The leaky bucket algorithm is also used in leaky bucket counters, e.g. to detect when the average or peak rate of random or stochastic events or stochastic processes, such as faults or failures, exceed defined limits. At least some implementations of the leaky bucket are a mirror image of the Token Bucket algorithm and will, given equivalent parameters, determine exactly the same sequence of events to conform or not conform to the same limits. However, there are at least two different descriptions of the leaky bucket that can and have caused confusion."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_lock> <http://dbpedia.org/ontology/abstract> "In computer science, a lock or mutex (from mutual exclusion) is a synchronization mechanism for enforcing limits on access to a resource in an environment where there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_message_broker> <http://dbpedia.org/ontology/abstract> "A message broker (also known as an integration broker or interface engine) is an intermediary computer program module that translates a message from the formal messaging protocol of the sender to the formal messaging protocol of the receiver. Message brokers are elements in telecommunication or computer networks where software applications communicate by exchanging formally-defined messages. Message brokers are a building block of message-oriented middleware (MOM) but are typically not a replacement for traditional middleware like MOM and remote procedure call (RPC)."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_load_balancing> <http://dbpedia.org/ontology/abstract> "In computing, load balancing improves the distribution of workloads across multiple computing resources, such as computers, a computer cluster, network links, central processing units, or disk drives. Load balancing aims to optimize resource use, maximize throughput, minimize response time, and avoid overload of any single resource. Using multiple components with load balancing instead of a single component may increase reliability and availability through redundancy. Load balancing usually involves dedicated software or hardware, such as a multilayer switch or a Domain Name System server process. Load balancing differs from channel bonding in that load balancing divides traffic between network interfaces on a network socket (OSI model layer 4) basis, while channel bonding implies a division of traffic between physical interfaces at a lower level, either per packet (OSI model Layer 3) or on a data link (OSI model Layer 2) basis with a protocol like shortest path bridging."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_memento> <http://dbpedia.org/ontology/abstract> "The memento pattern is a software design pattern that provides the ability to restore an object to its previous state (undo via rollback). The memento pattern is implemented with three objects: the originator, a caretaker and a memento. The originator is some object that has an internal state. The caretaker is going to do something to the originator, but wants to be able to undo the change. The caretaker first asks the originator for a memento object. Then it does whatever operation (or sequence of operations) it was going to do. To roll back to the state before the operations, it returns the memento object to the originator. The memento object itself is an opaque object (one which the caretaker cannot, or should not, change). When using this pattern, care should be taken if the originator may change other objects or resources - the memento pattern operates on a single object. Classic examples of the memento pattern include the seed of a pseudorandom number generator (it will always produce the same sequence thereafter when initialized with the seed state) and the state in a finite state machine."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_map_reduce> <http://dbpedia.org/ontology/abstract> "MapReduce is a programming model and an associated implementation for processing and generating big data sets with a parallel, distributed algorithm on a cluster. A MapReduce program is composed of a map procedure, which performs filtering and sorting (such as sorting students by first name into queues, one queue for each name), and a reduce method, which performs a summary operation (such as counting the number of students in each queue, yielding name frequencies). The \"MapReduce System\" (also called \"infrastructure\" or \"framework\") orchestrates the processing by marshalling the distributed servers, running the various tasks in parallel, managing all communications and data transfers between the various parts of the system, and providing for redundancy and fault tolerance. The model is a specialization of the split-apply-combine strategy for data analysis.It is inspired by the map and reduce functions commonly used in functional programming, although their purpose in the MapReduce framework is not the same as in their original forms. The key contributions of the MapReduce framework are not the actual map and reduce functions (which, for example, resemble the 1995 Message Passing Interface standard's reduce and scatter operations), but the scalability and fault-tolerance achieved for a variety of applications by optimizing the execution engine. As such, a single-threaded implementation of MapReduce is usually not faster than a traditional (non-MapReduce) implementation; any gains are usually only seen with multi-threaded implementations on multi-processor hardware. The use of this model is beneficial only when the optimized distributed shuffle operation (which reduces network communication cost) and fault tolerance features of the MapReduce framework come into play. Optimizing the communication cost is essential to a good MapReduce algorithm. MapReduce libraries have been written in many programming languages, with different levels of optimization. A popular open-source implementation that has support for distributed shuffles is part of Apache Hadoop. The name MapReduce originally referred to the proprietary Google technology, but has since been genericized. By 2014, Google was no longer using MapReduce as their primary big data processing model, and development on Apache Mahout had moved on to more capable and less disk-oriented mechanisms that incorporated full map and reduce capabilities."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_mediator> <http://dbpedia.org/ontology/abstract> "In software engineering, the mediator pattern defines an object that encapsulates how a set of objects interact. This pattern is considered to be a behavioral pattern due to the way it can alter the program's running behavior. In object-oriented programming, programs often consist of many classes. Business logic and computation are distributed among these classes. However, as more classes are added to a program, especially during maintenance and/or refactoring, the problem of communication between these classes may become more complex. This makes the program harder to read and maintain. Furthermore, it can become difficult to change the program, since any change may affect code in several other classes. With the mediator pattern, communication between objects is encapsulated within a mediator object. Objects no longer communicate directly with each other, but instead communicate through the mediator. This reduces the dependencies between communicating objects, thereby reducing coupling."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_microservices> <http://dbpedia.org/ontology/abstract> "Microservices are a software development technique —a variant of the service-oriented architecture (SOA) structural style— that arranges an application as a collection of loosely coupled services. In a microservices architecture, services are fine-grained and the protocols are lightweight."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_modal_window> <http://dbpedia.org/ontology/abstract> "In user interface design for computer applications, a modal window is a graphical control element subordinate to an application's main window. It creates a mode that disables the main window but keeps it visible, with the modal window as a child window in front of it. Users must interact with the modal window before they can return to the parent application. This avoids interrupting the workflow on the main window. Modal windows are sometimes called heavy windows or modal dialogs because they often display a dialog box. User interfaces typically use modal windows to command user awareness and to display emergency states, though interaction designers argue they are ineffective for that use. Modal windows are prone to mode errors. On the Web, they often show images in detail, such as those implemented by Lightbox library, or are used for hover ads. The opposite of modal is modeless. Modeless windows don't block the main window, so the user can switch their focus between them, treating them as palette windows."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_model-view-controller> <http://dbpedia.org/ontology/abstract> "Model–view–controller (usually known as MVC) is a software design pattern commonly used for developing user interfaces which divides the related program logic into three interconnected elements. This is done to separate internal representations of information from the ways information is presented to and accepted from the user. This kind of pattern is used for designing the layout of the page. Traditionally used for desktop graphical user interfaces (GUIs), this pattern has become popular for designing web applications. Popular programming languages like JavaScript, Python, Ruby, PHP, Java, C#, and Swift have MVC frameworks that are used for web or mobile application development straight out of the box."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_module> <http://dbpedia.org/ontology/abstract> "In software engineering, the module pattern is a design pattern used to implement the concept of software modules, defined by modular programming, in a programming language with incomplete direct support for the concept. This pattern can be implemented in several ways depending on the host programming language, such as the singleton design pattern, object-oriented  in a class and procedural global functions. In Python, the pattern is built into the language, and each .py file is automatically a module."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_layered_architecture> <http://dbpedia.org/ontology/abstract> "In software engineering, multitier architecture (often referred to as n-tier architecture) or multilayered architecture is a client–server architecture in which presentation, application processing, and data management functions are physically separated. The most widespread use of multitier architecture is the three-tier architecture. N-tier application architecture provides a model by which developers can create flexible and reusable applications. By segregating an application into tiers, developers acquire the option of modifying or adding a specific layer, instead of reworking the entire application. A three-tier architecture is typically composed of a presentation tier, a domain logic tier, and a data storage tier. While the concepts of layer and tier are often used interchangeably, one fairly common point of view is that there is indeed a difference. This view holds that a layer is a logical structuring mechanism for the elements that make up the software solution, while a tier is a physical structuring mechanism for the system infrastructure. For example, a three-layer solution could easily be deployed on a single tier, such as a personal workstation."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_object_pool> <http://dbpedia.org/ontology/abstract> "The object pool pattern is a software creational design pattern that uses a set of initialized objects kept ready to use – a \"pool\" – rather than allocating and destroying them on demand. A client of the pool will request an object from the pool and perform operations on the returned object. When the client has finished, it returns the object to the pool rather than destroying it; this can be done manually or automatically. Object pools are primarily used for performance: in some circumstances, object pools significantly improve performance. Object pools complicate object lifetime, as objects obtained from and returned to a pool are not actually created or destroyed at this time, and thus require care in implementation."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_observer> <http://dbpedia.org/ontology/abstract> "The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods. It is mainly used to implement distributed event handling systems, in \"event driven\" software. In those systems, the subject is usually called a \"stream of events\" or \"stream source of events\", while the observers are called \"sink of events\". The stream nomenclature simulates or adapts to a physical setup where the observers are physically separated and have no control over the emitted events of the subject/stream-source. This pattern then perfectly suits any process where data arrives through I/O, that is, where data is not available to the CPU at startup, but can arrive \"randomly\" (HTTP requests, GPIO data, user input from keyboard/mouse/..., distributed databases and blockchains, ...). Most modern languages have built-in \"event\" constructs which implement the observer pattern components. While not mandatory most 'observers' implementations will use background threads listening for subject events and other support mechanism from the kernel (Linux epoll, ...)"@en .
<http://star.siemens.com/ontology/instance#DesignPattern_priority_queue_pattern> <http://dbpedia.org/ontology/abstract> "In computer science, a priority queue is an abstract data type which is like a regular queue or stack data structure, but where additionally each element has a \"priority\" associated with it. In a priority queue, an element with high priority is served before an element with low priority. In some implementations, if two elements have the same priority, they are served according to the order in which they were enqueued, while in other implementations, ordering of elements with the same priority is undefined. While priority queues are often implemented with heaps, they are conceptually distinct from heaps. A priority queue is a concept like \"a list\" or \"a map\"; just as a list can be implemented with a linked list or an array, a priority queue can be implemented with a heap or a variety of other methods such as an unordered array."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_prototype> <http://dbpedia.org/ontology/abstract> "The prototype pattern is a creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, which is cloned to produce new objects. This pattern is used to: \n* avoid subclasses of an object creator in the client application, like the factory method pattern does. \n* avoid the inherent cost of creating a new object in the standard way (e.g., using the 'new' keyword) when it is prohibitively expensive for a given application. To implement the pattern, declare an abstract base class that specifies a pure virtual clone() method. Any class that needs a \"polymorphic constructor\" capability derives itself from the abstract base class, and implements the clone() operation. The client, instead of writing code that invokes the \"new\" operator on a hard-coded class name, calls the clone() method on the prototype, calls a factory method with a parameter designating the particular concrete derived class desired, or invokes the clone() method through some mechanism provided by another design pattern. The mitotic division of a cell — resulting in two identical cells — is an example of a prototype that plays an active role in copying itself and thus, demonstrates the Prototype pattern. When a cell splits, two cells of identical genotype result. In other words, the cell clones itself."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_platform_invoke> <http://dbpedia.org/ontology/abstract> "Platform Invocation Services, commonly referred to as P/Invoke, is a feature of Common Language Infrastructure implementations, like Microsoft's Common Language Runtime, that enables managed code to call native code. Managed code, such as C# or VB.NET, provides native access to classes, methods, and types defined within the libraries that make up the .NET framework. While the .NET framework provides an extensive set of functionality, it may lack access to many lower level operating system libraries normally written in unmanaged code or third party libraries also written in unmanaged code. P/Invoke is the technique a programmer can use to access functions in these libraries. Calls to functions within these libraries occur by declaring the signature of the unmanaged function within managed code, which serves as the actual function that can be called like any other managed method. The declaration references the library's file path and defines the function parameters and return in managed types that are most likely to be implicitly marshaled to and from the unmanaged types by the common language run-time (CLR). When the unmanaged data types become too complex for a simple implicit conversion from and to managed types, the framework allows the user to define attributes on the function, return, and/or the parameters to explicitly refine how the data should be marshaled so as not to lead to exceptions in trying to do so implicitly. There are many abstractions of lower level programming concepts available to managed code programmers as compared to programming in unmanaged languages. As a result, a programmer with only managed code experience will need to brush up on programming concepts such as pointers, structures, and passing by reference to overcome some of the more basic, but common obstacles in using P/Invoke."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_proxy> <http://dbpedia.org/ontology/abstract> "In computer programming, the proxy pattern is a software design pattern. A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply be forwarding to the real object, or can provide additional logic. In the proxy, extra functionality can be provided, for example caching when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked. For the client, usage of a proxy object is similar to using the real object, because both implement the same interface."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_reflection> <http://dbpedia.org/ontology/abstract> "In computer science, reflection is the ability of a process to examine, introspect, and modify its own structure and behavior."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_pubsub> <http://dbpedia.org/ontology/abstract> "In software architecture, publish–subscribe is a messaging pattern where senders of messages, called publishers, do not program the messages to be sent directly to specific receivers, called subscribers, but instead categorize published messages into classes without knowledge of which subscribers, if any, there may be. Similarly, subscribers express interest in one or more classes and only receive messages that are of interest, without knowledge of which publishers, if any, there are. Publish–subscribe is a sibling of the message queue paradigm, and is typically one part of a larger message-oriented middleware system. Most messaging systems support both the pub/sub and message queue models in their API, e.g. Java Message Service (JMS). This pattern provides greater network scalability and a more dynamic network topology, with a resulting decreased flexibility to modify the publisher and the structure of the published data."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_replication> <http://dbpedia.org/ontology/abstract> "Replication in computing involves sharing information so as to ensure consistency between redundant resources, such as software or hardware components, to improve reliability, fault-tolerance, or accessibility."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_representational_state_transfer> <http://dbpedia.org/ontology/abstract> "Representational state transfer (REST) is a software architectural style that defines a set of constraints to be used for creating Web services. Web services that conform to the REST architectural style, called RESTful Web services, provide interoperability between computer systems on the Internet. RESTful Web services allow the requesting systems to access and manipulate textual representations of Web resources by using a uniform and predefined set of stateless operations. Other kinds of Web services, such as SOAP Web services, expose their own arbitrary sets of operations. \"Web resources\" were first defined on the World Wide Web as documents or files identified by their URLs. However, today they have a much more generic and abstract definition that encompasses every thing or entity that can be identified, named, addressed, or handled, in any way whatsoever, on the Web. In a RESTful Web service, requests made to a resource's URI will elicit a response with a payload formatted in HTML, XML, JSON, or some other format. The response can confirm that some alteration has been made to the stored resource, and the response can provide hypertext links to other related resources or collections of resources. When HTTP is used, as is most common, the operations (HTTP methods) available are GET, HEAD, POST, PUT, PATCH, DELETE, CONNECT, OPTIONS and TRACE. By using a stateless protocol and standard operations, RESTful systems aim for fast performance, reliability, and the ability to grow by reusing components that can be managed and updated without affecting the system as a whole, even while it is running. The term representational state transfer was introduced and defined in 2000 by Roy Fielding in his doctoral dissertation. Fielding's dissertation explained the REST principles that were known as the \"HTTP object model\" beginning in 1994, and were used in designing the HTTP 1.1 and Uniform Resource Identifiers (URI) standards. The term is intended to evoke an image of how a well-designed Web application behaves: it is a network of Web resources (a virtual state-machine) where the user progresses through the application by selecting resource identifiers such as http://www.example.com/articles/21 and resource operations such as GET or POST (application state transitions), resulting in the next resource's representation (the next application state) being transferred to the end user for their use."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_rest_architecture> <http://dbpedia.org/ontology/abstract> "In software engineering, a resource-oriented architecture (ROA) is a style of software architecture and programming paradigm for supportive designing and developing software in the form of Internetworking of resources with \"RESTful\" interfaces. These resources are software components (discrete pieces of code and/or data structures) which can be reused for different purposes. ROA design principles and guidelines are used during the phases of software development and system integration. REST, or Representational State Transfer, describes a series of architectural constraints that exemplify how the web's design emerged. Various concrete implementations of these ideas have been created throughout time, but it has been difficult to discuss the REST architectural style without blurring the lines between actual software and the architectural principles behind it. In Chapter 5 of his thesis, Roy Fielding documents how the World Wide Web is designed to be constrained by the REST series of limitations. These are still fairly abstract and have been interpreted in various ways in designing new frameworks, systems, and websites. In the past, heated exchanges have been made about whether RPC-style REST architectures are RESTful."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_root_cause_analysis> <http://dbpedia.org/ontology/abstract> "In science and engineering, root cause analysis (RCA) is a method of problem solving used for identifying the root causes of faults or problems. It is widely used in IT operations, telecommunications, industrial process control, accident analysis (e.g., in aviation, rail transport, or nuclear plants), medicine (for medical diagnosis), healthcare industry (e.g., for epidemiology), etc. RCA can be decomposed into four steps: \n* Identify and describe the Problem clearly. \n* Establish a timeline from the normal situation up to the time the problem occurred. \n* Distinguish between the root cause and other causal factors (e.g., using event correlation). \n* Establish a causal graph between the root cause and the problem. RCA generally serves as input to a remediation process whereby corrective actions are taken to prevent the problem from reoccurring. The name of this process varies from one application domain to another."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_secure_channels> <http://dbpedia.org/ontology/abstract> "In cryptography, a secure channel is a way of transferring data that is resistant to overhearing and tampering. A  is a way of transferring data that is resistant to overhearing (i.e., reading the content), but not necessarily resistant to tampering. An  is a way of transferring data that is resistant to tampering but not necessarily resistant to overhearing."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_serialization> <http://dbpedia.org/ontology/abstract> "In computer science, in the context of data storage, serialization (or serialisation) is the process of translating data structures or object state into a format that can be stored (for example, in a file or memory buffer) or transmitted (for example, across a network connection link) and reconstructed later (possibly in a different computer environment). When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object. For many complex objects, such as those that make extensive use of references, this process is not straightforward. Serialization of object-oriented objects does not include any of their associated methods with which they were previously linked. This process of serializing an object is also called marshalling an object in some situations. The opposite operation, extracting a data structure from a series of bytes, is deserialization (also called unmarshalling)."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_service-oriented_architecture> <http://dbpedia.org/ontology/abstract> "Service-oriented architecture (SOA) is a style of software design where services are provided to the other components by application components, through a communication protocol over a network. A SOA service is a discrete unit of functionality that can be accessed remotely and acted upon and updated independently, such as retrieving a credit card statement online. SOA is also intended to be independent of vendors, products and technologies. A service has four properties according to one of many definitions of SOA: 1.  \n* It logically represents a business activity with a specified outcome. 2.  \n* It is self-contained. 3.  \n* It is a black box for its consumers, meaning the consumer does not have to be aware of the service's inner workings. 4.  \n* It may consist of other underlying services. Different services can be used in conjunction to provide the functionality of a large software application, a principle SOA shares with modular programming. Service-oriented architecture integrates distributed, separately maintained and deployed software components. It is enabled by technologies and standards that facilitate components' communication and cooperation over a network, especially over an IP network. SOA is related to the idea of an application programming interface (API), an interface or communication protocol between different parts of a computer program intended to simplify the implementation and maintenance of software. An API can be thought of as the service, and the SOA the architecture that allows the service to operate."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_service_orientation> <http://dbpedia.org/ontology/abstract> "Service-orientation is a design paradigm for computer software in the form of services. The principles of service-oriented design stress the separation of concerns in the software. Applying service-orientation results in units of software partitioned into discrete, autonomous, and network-accessible units, each designed to solve an individual concern. These units qualify as services."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_state> <http://dbpedia.org/ontology/abstract> "The state pattern is a behavioral software design pattern that allows an object to alter its behavior when its internal state changes. This pattern is close to the concept of finite-state machines. The state pattern can be interpreted as a strategy pattern, which is able to switch a strategy through invocations of methods defined in the pattern's interface. The state pattern is used in computer programming to encapsulate varying behavior for the same object, based on its internal state. This can be a cleaner way for an object to change its behavior at runtime without resorting to conditional statements and thus improve maintainability."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_singleton> <http://dbpedia.org/ontology/abstract> "In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one \"single\" instance. This is useful when exactly one object is needed to coordinate actions across the system. The term comes from the mathematical concept of a singleton. Critics consider the singleton to be an anti-pattern in that it is frequently used in scenarios where it is not beneficial, introduces unnecessary restrictions in situations where a sole instance of a class is not actually required, and introduces global state into an application."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_strategy> <http://dbpedia.org/ontology/abstract> "In computer programming, the strategy pattern (also known as the policy pattern) is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use. Strategy lets the algorithm vary independently from clients that use it. Strategy is one of the patterns included in the influential book Design Patterns by Gamma et al. that popularized the concept of using design patterns to describe how to design flexible and reusable object-oriented software. Deferring the decision about which algorithm to use until runtime allows the calling code to be more flexible and reusable. For instance, a class that performs validation on incoming data may use the strategy pattern to select a validation algorithm depending on the type of data, the source of the data, user choice, or other discriminating factors. These factors are not known until run-time and may require radically different validation to be performed. The validation algorithms (strategies), encapsulated separately from the validating object, may be used by other validating objects in different areas of the system (or even different systems) without code duplication. Typically the strategy pattern stores a reference to some code in a data structure and retrieves it. This can be achieved by mechanisms such as the native function pointer, the first-class function, classes or class instances in object-oriented programming languages, or accessing the language implementation's internal storage of code via reflection."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_template_method> <http://dbpedia.org/ontology/abstract> "In object-oriented programming, the template method is one of the behavioral design patterns identified by Gamma et al. in the book Design Patterns. The template method is a method in a superclass, usually an abstract superclass, and defines the skeleton of an operation in terms of a number of high-level steps. These steps are themselves implemented by additional helper methods in the same class as the template method. The helper methods may be either abstract methods, for which case subclasses are required to provide concrete implementations, or , which have empty bodies in the superclass. Subclasses can (but are not required to) customize the operation by overriding the hook methods. The intent of the template method is to define the overall structure of the operation, while allowing subclasses to refine, or redefine, certain steps."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_virtual_address_space> <http://dbpedia.org/ontology/abstract> "In computing, a virtual address space (VAS) or address space is the set of ranges of virtual addresses that an operating system makes available to a process. The range of virtual addresses usually starts at a low address and can extend to the highest address allowed by the computer's instruction set architecture and supported by the operating system's pointer size implementation, which can be 4 bytes for 32-bit or 8 bytes for 64-bit OS versions. This provides several benefits, one of which is security through process isolation assuming each process is given a separate address space."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_virtual_functions> <http://dbpedia.org/ontology/abstract> "In object-oriented programming, in languages such as C++, and Object Pascal, a virtual function or virtual method is an inheritable and overridable function or method for which dynamic dispatch is facilitated. This concept is an important part of the (runtime) polymorphism portion of object-oriented programming (OOP). In short, a virtual function defines a target function to be executed, but the target might not be known at compile time."@en .
<http://star.siemens.com/ontology/instance#DesignPattern_visitor> <http://dbpedia.org/ontology/abstract> "In object-oriented programming and software engineering, the visitor design pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying the structures. It is one way to follow the open/closed principle. In essence, the visitor allows adding new virtual functions to a family of classes, without modifying the classes. Instead, a visitor class is created that implements all of the appropriate specializations of the virtual function. The visitor takes the instance reference as input, and implements the goal through double dispatch."@en .
